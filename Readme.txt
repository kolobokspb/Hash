1. Target framework .NET 6.0
2. HashCalculator.exe запускается из-под cmd с параметрами КС. Первый аргумент - путь до файла, второй - размер блока.
3. Чтение файла осуществляется последовательно, т.к поведение устройства, содержащего файл, непредсказуемо. Например, если это - HDD или СХД, содержащая в своём составе HDD, то операции параллельного чтения могут привести к непредсказуемому падению производительности. 
4. Выбраны 2 стратегии поведения программы для разной величины блока:
  a) До 1GB. В отдельном потоке "загрузчик" загружает с устройства блоки полностью в память и добавляет в очередь "загруженых блоков". Из очереди "загруженых блоков"  блоки забираются и отправляются на обработку доступному потоку. После расчёта хеша блок возвращается обратно в очередь "свободных блоков". 
  б) Более 1GB. Загрузка с устройства и расчёт осуществляются в одном потоке.
5. Т.к. алгоритм загрузки с устройства и отправка на вычисление хеша достаточно универсальны, то посчитал правильным сделать класс generic, чтобы можно было заменить алгоритм хэширования
6. К сожалению, интерфейс класса расчета SHA256 не позволяет скармливать данные по частям и принуждает это делать только через Stream. Это скорее всего можно обойти через рефлекшен, но в данной задаче я решил к этому способу не прибегать.
7. Алгоритм загрузки и расчета находится в отдельной сборке для уменьшения проверок внутренних входных параметров и доступности типов конечному пользователю.

Тестирование:
1. Для маленьких блоков узким местом является вывод данных на консоль, а не вычисление или загрузка с устройства. Поэтому от вывода на консоль надо полностью отказываться или буфферезировать.  
2. Для загрузки на 100% USB HDD (со скоростью чтения ~42MB) достаточно блоков в 1MB.
3. Для загрузки на 100% процессора i7-8700К мне понадобилось снизить частоту процессора, установить блоки в 100Мб и читать с SSD Samsung 960Pro cо скоростью ~1.0 GB/c.
4. Для загрузки на ~96% SSD Samsung 960Pro потребовались блоки 100Мб (могут быть и меньше, но уперлись в консоль) и i7-8700К с несниженной частотой.

Что можно улучшить и общие идеи:
1. Не буфферезированное чтение (FILE_FLAG_NO_BUFFERING, 0x20000000) работает быстрее на ~15-20% для SSD на моей машине, но требуется более аккуратное обращение с чтением. Без этого флага загрузка не поднимается выше 75-85%  
2. Возможно, скорость чтения стоит оценивать в динамике и сделать алгоритм адаптивным.
